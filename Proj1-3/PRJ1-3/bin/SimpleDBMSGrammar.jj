options{  static = true;  DEBUG_PARSER = false;  IGNORE_CASE = true;}PARSER_BEGIN(SimpleDBMSParser)//importimport com.sleepycat.je.Database;import com.sleepycat.je.DatabaseException;import com.sleepycat.je.DatabaseConfig;import com.sleepycat.je.DatabaseEntry;import com.sleepycat.je.Cursor;import com.sleepycat.je.Environment;import com.sleepycat.je.EnvironmentConfig;import com.sleepycat.je.LockMode;import com.sleepycat.je.OperationStatus;import java.io.File;import java.io.UnsupportedEncodingException;import java.util.ArrayList;import java.util.Iterator;import custom.*;import java.lang.Math;import com.sleepycat.bind.EntryBinding;import com.sleepycat.bind.serial.StoredClassCatalog;import com.sleepycat.bind.serial.SerialBinding;public class SimpleDBMSParser{  /*Query Return values */  public static final int PRINT_CREATE_TABLE = 1;  public static final int PRINT_DROP_TABLE = 2;  public static final int PRINT_DESC = 3;  public static final int PRINT_SHOW_TABLES = 4;  public static final int PRINT_SELECT = 5;  public static final int PRINT_INSERT = 6;  public static final int PRINT_DELETE = 7;  public static DatabaseHandler DBH = new DatabaseHandler();  public static DatabaseManage DM = new DatabaseManage(DBH);  public static DatabaseDefine DD = new DatabaseDefine(DBH);  public static void main(String args[]) throws ParseException  {        SimpleDBMSParser parser = new SimpleDBMSParser(System.in);    System.out.print("DB_2014-10469> ");    while (true)    {      try      {        parser.command();              }      catch (Exception e)      {        errorMsg.printMessage(errorMsg.PRINT_SYNTAX_ERROR, "", true);        //System.out.println(e.getMessage()); // for Debug, if you remove comment symbol, you can see what token is not matched when error comes.        SimpleDBMSParser.ReInit(System.in);      }    }  }}  PARSER_END(SimpleDBMSParser)//these characters in the middle of tokens will be ignored.SKIP : { " " | "\r" | "\t" | "\n" }TOKEN : /* Keywords */// keywords should be ABOVE any other tokens because this arrangement can catch violation on using keywords {  < EXIT : "exit" >| < INT : "int" >| < CHAR : "char" >| < DATE : "date" >| < CREATE_TABLE : "create table" >| < NOT : "not" >| < NULL : "null" >| < NOT_NULL : "not null" >| < PRIMARY_KEY : "primary key" >| < FOREIGN_KEY : "foreign key" >| < REFERENCES : "references" >| < DROP_TABLE : "drop table" >| < DESC : "desc" >| < SHOW_TABLES : "show tables" >| < SELECT : "select" >| < AS : "as" >| < FROM : "from" >| < WHERE : "where" >| < OR : "or" >| < AND : "and" >| < IS : "is" >| < INSERT_INTO : "insert into" >| < VALUES : "values" >| < DELETE_FROM : "delete from" >| < STAR : "*" >} < STRING >TOKEN :{  < SPACE : " " >| < NON_QUOTE_CHARACTER : < DIGIT > | < ALPHABET > | < NON_QUOTE_SPECIAL_CHARACTERS > | < SPACE > >| < NON_QUOTE_SPECIAL_CHARACTERS : "!" | "@" | "#" | "~" | "`" | "$" | "%" | "^" | "&" | "*" | "(" | ")" |								   "_" | "-" | "[" | "]" | "{" | "}" | "\\" | "|" | ";" | ":" | "<" | ">" |								   "," | "." | "/" | "?" | "+" | "=" >}TOKEN :{  < PERIOD : "." >| < SEMICOLON : ";" >| < LEFT_PAREN : "(" >| < RIGHT_PAREN : ")" >| < COMMA : "," >| < UNDERSCORE : "_" >| < INT_VALUE : (< SIGN >)? (< DIGIT >)+ >| < SIGN : "+" | "-" >| < QUOTE : "\'" > | < DATE_VALUE : < NNNN > "-" <NN > "-" < NN > >| < NNNN : < DIGIT > <DIGIT > <DIGIT > <DIGIT > >| < NN : < DIGIT > < DIGIT > >| < LEGAL_IDENTIFIER : < ALPHABET > (< ALPHABET > | < UNDERSCORE >)* >| < COMP_OP : "<" | ">" | "=" | ">=" | "<=" | "!=" >| < CHAR_STRING : < QUOTE > (< NON_QUOTE_CHARACTER >)* < QUOTE > >| < DIGIT : [ "0"-"9" ] >| < ALPHABET : [ "a"-"z", "A"-"Z" ] >| < DOUBLE_QUOTE : "\"" > // this token never used but should be defined because it can be typed into input.}//parse the whole SQL commandvoid command():{}{  queryList()| (    < EXIT >    < SEMICOLON >    {       DBH.close();       System.exit(0);    }  ) }//parse querylist = > query;query;query;...//after parse each query, it print message according to query comment numbervoid queryList():{  int q;  queryConfig qC = new queryConfig(); //contains information from query to use after syntax check.}{  (    q = query(qC)    < SEMICOLON >    {	  switch(q)	  {	    case PRINT_CREATE_TABLE:	    	//check if primary definition is more than 1 	    	if(qC.primary_def_count > 1)	    	{ 	    		errorMsg.printMessage(errorMsg.DUPLICATE_PRIMARYKEY_DEF_ERROR, "", true);	    		return;	        }	    	DD.createTable(qC.table);	    	break;		case PRINT_DROP_TABLE:			DD.dropTable(qC.table_name);			break;  		case PRINT_DESC:  			DD.desc(qC.table_name);  			break;  		case PRINT_SHOW_TABLES:  			DD.showTables();  			break;  		case PRINT_SELECT:  			DM.select(qC.select_name_list, qC.select_table_name_list, qC.where_expression);  			break;  		case PRINT_INSERT:  			DM.insert(qC.table_name, qC.record, qC.record_match_attributes);  			break;  		case PRINT_DELETE:  			DM.delete(qC.table_name, qC.where_expression);  			break;       }       //error handling here **************************************************       qC = new queryConfig();    }  )+}// parse queryint query(queryConfig qC):{  int q; // it will be Query Comment Number.}{  (    qC.primary_def_count = createTableQuery(qC.table)    {      q = PRINT_CREATE_TABLE;    }|  	qC.table_name = dropTableQuery()  	{  	  q = PRINT_DROP_TABLE;  	}| 	qC.table_name = descQuery() 	{ 	  q = PRINT_DESC;  	}|	showTablesQuery()	{	  q = PRINT_SHOW_TABLES;	}|	selectQuery(qC)	{	  q = PRINT_SELECT;	}|	insertQuery(qC)	{	  q = PRINT_INSERT;	}|	deleteQuery(qC)	{	  q = PRINT_DELETE;	}  )  (    {      return q;    }  )}void deleteQuery(queryConfig qC) :{}{  < DELETE_FROM >  qC.table_name = tableName()  (    whereClause(qC.where_expression)  )?}void insertQuery(queryConfig qC) :{}{  < INSERT_INTO >  qC.table_name = tableName()  insertColumnsAndSource(qC)}void insertColumnsAndSource(queryConfig qC) :{	ArrayList<String> RMA = new ArrayList<String>();	ArrayList<Types> values; }{  (    RMA = columnNameList()  )?  values = valueList()  {    qC.record_match_attributes = RMA;    qC.record = values;  }}ArrayList<Types> valueList() :{	ArrayList<Types> VL = new ArrayList<Types>();  }{  < VALUES >  < LEFT_PAREN >  value(VL)  (    < COMMA >    value(VL)  )*  < RIGHT_PAREN >  {	return VL;  }}void value(ArrayList<Types> VL) :{  Types value;}{  < NULL >  {	VL.add((Types) new NullType());  }  | value = comparableValue() { VL.add(value); }}void selectQuery(queryConfig qC) :{}{  < SELECT >  selectList(qC.select_name_list)  tableExpression(qC)}void tableExpression(queryConfig qC) :{}{  fromClause(qC.select_table_name_list)  (    whereClause(qC.where_expression)  )?}void whereClause(ExpressionType WE) :{}{  < WHERE >  booleanValueExpression(WE)}void booleanValueExpression(ExpressionType WE) :{	Token t;}{  {    WE.left_operand = new ExpressionType();  }  booleanTerm((ExpressionType) WE.left_operand)  (    t = < OR >    {      WE.right_operand = new ExpressionType();      WE.operator = t.toString();    }    booleanTerm((ExpressionType) WE.right_operand)  )*}void booleanTerm(ExpressionType WE) :{	Token t;}{  {    WE.left_operand = new ExpressionType();  }  booleanFactor((ExpressionType) WE.left_operand)  (    t = < AND >    {      WE.right_operand = new ExpressionType();      WE.operator = t.toString();    }    booleanFactor((ExpressionType) WE.right_operand)  )*}void booleanFactor(ExpressionType WE) :{  	ExpressionType temp = WE;  	Token t;}{  (    t = < NOT >    {      WE.left_operand = (Types) new ExpressionType();	  WE.operator = t.toString();	  temp = (ExpressionType) WE.left_operand;    }  )?  booleanTest(temp)}void booleanTest(ExpressionType WE) :{}{  predicate(WE) | parenthesizedBooleanExpression(WE)}void parenthesizedBooleanExpression(ExpressionType WE) :{}{  < LEFT_PAREN >  booleanValueExpression(WE)  < RIGHT_PAREN >}void predicate(ExpressionType WE) :{}{  LOOKAHEAD(4) // it can solve the conflict comparisonPredicate() and nullPredicate()  comparisonPredicate(WE)  |  nullPredicate(WE)}void nullPredicate(ExpressionType WE) :{  SelectName sn = new SelectName();}{  (    LOOKAHEAD(2) // it can solve the conflict tableName()and columnName()     sn.tname = tableName()    < PERIOD >  )?  sn.cname = columnName()  WE.operator = nullOperation()  {    WE.left_operand = (Types) new VarType(sn);  }}String nullOperation() :{	String temp;}{  < IS >  (        (      < NOT > < NULL > { temp = "not_null"; }    )  | < NULL > { temp = "null"; }  | < NOT_NULL > { temp = "not_null"; }  )   {	return temp;  }}void comparisonPredicate(ExpressionType WE) :{  Token t;}{  WE.left_operand = compOperand()  t = < COMP_OP >  WE.right_operand = compOperand()  {	WE.operator = t.toString();  }}Types compOperand() :{  Types temp;  SelectName sn = new SelectName();}{  (    	  temp = comparableValue()	  |	    (	      (	        LOOKAHEAD(2) // it can solve the conflict tableName()and columnName() 	        sn.tname = tableName()	        < PERIOD >	      )?	      sn.cname = columnName()	      {	        temp = (Types) new VarType(sn);	      }	    )  )  {    return temp;  }}Types comparableValue() :{  Types temp;  Token t;}{  (    ( t = < INT_VALUE > { temp = (Types) new IntType(t.toString()); } )  | ( t = < CHAR_STRING > { temp = (Types) new CharType(t.toString()); } )  | ( t = < DATE_VALUE > { temp = (Types) new DateType(t.toString()); } )  )  {	return temp;  }  }void fromClause(ArrayList<SelectName> STNL) :{}{  < FROM >  tableReferenceList(STNL)}void tableReferenceList(ArrayList<SelectName> STNL) :{}{  referedTable(STNL)  (    < COMMA >    referedTable(STNL)  )*}void referedTable(ArrayList<SelectName> STNL) :{  SelectName temp = new SelectName();}{  temp.tname = tableName()  {  }  (    < AS >    temp.dname = tableName()  )?  {    STNL.add(temp);  }}void selectList(ArrayList<SelectName> SNL) :{}{  < STAR >  {	SNL.add(new SelectName("*", "", ""));  }|  (    selectedColumn(SNL)    (      < COMMA >      selectedColumn(SNL)    )*  )}void selectedColumn(ArrayList<SelectName> SNL) :{  SelectName SN = new SelectName();}{  (    LOOKAHEAD(2) // it can solve the conflict tableName()and columnName()     SN.tname = tableName()    < PERIOD >  )?  SN.cname = columnName()  (    < AS >    SN.dname = columnName()  )?  {    SNL.add(SN);  }}  void showTablesQuery() :{}{  < SHOW_TABLES >}String descQuery() :{  String table_name;} {  < DESC >  table_name = tableName()  {  return table_name;  }}String dropTableQuery() :{  String table_name;}{  < DROP_TABLE >  table_name = tableName()  {  return table_name;  }}int createTableQuery(Table table):{  int pdc = 0;}{	  < CREATE_TABLE >	  table.table_name = tableName()	  pdc = tableElementList(table)	  {	    return pdc;	  }}int tableElementList(Table table):{	int primary_def_count = 0;	int temp;}{  < LEFT_PAREN >  temp = tableElement(table)  {    primary_def_count += temp;  }  (    < COMMA >    temp = tableElement(table)    {      primary_def_count += temp;    }  )*  < RIGHT_PAREN >  {    return primary_def_count;  }}int tableElement(Table table):{  Attribute attribute = new Attribute();  int primary_def_count = 0;}{  (      (      columnDefinition(attribute)    {  		table.attributes.add(attribute);    }  )	| primary_def_count = tableConstraintDefinition(table))  {    return primary_def_count;  }}void columnDefinition(Attribute attribute) :{  String temp;}{  temp = columnName()  {    attribute.set_name(temp);  }  dataType(attribute)  (     < NOT_NULL >    {      attribute.set_is_null(false);    }  )?}int tableConstraintDefinition(Table table) :{	int primary_def_count = 0;}{  (    primaryKeyConstraint(table)    {      primary_def_count = 1;    }| referentialConstraint(table))  {	return primary_def_count;  }}void primaryKeyConstraint(Table table) :{}{  < PRIMARY_KEY >  table.primary_keys = columnNameList()}void referentialConstraint(Table table) :{	ArrayList<String> referencing;	ArrayList<String> referenced;	String reference_table;	Reference temp = new Reference();}	{  < FOREIGN_KEY >  referencing = columnNameList()  < REFERENCES >  reference_table = tableName()  referenced = columnNameList()  {    temp.refer_chaser_names = referencing;    temp.refer_target_names = referenced;    temp.refer_table = reference_table;    table.referencing.add(temp);      }}ArrayList<String> columnNameList() :{	ArrayList<String > list =  new ArrayList();	String temp;}{  < LEFT_PAREN >  temp = columnName()  {    list.add(temp);  }  (    < COMMA >    temp = columnName()    {      list.add(temp);    }  )*  < RIGHT_PAREN >  {	return list;  }}void dataType(Attribute attribute) :{  int type = 0;  Token length_temp;  }{  (      < INT > { type = 1; }| (    < CHAR >    < LEFT_PAREN >    length_temp = < INT_VALUE >    {      type = 2;      attribute.set_len(Integer.parseInt(length_temp.toString()));    }    < RIGHT_PAREN >  )| < DATE > { type = 3; })(	{		attribute.set_type(type);		return;	})}String tableName() :{  Token t; }{  (t = < LEGAL_IDENTIFIER >)  {	return t.toString();  }}String columnName() :{	Token t;  }{  t = < LEGAL_IDENTIFIER >  {    return t.toString();  }}