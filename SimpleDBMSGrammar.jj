options{  static = true;  DEBUG_PARSER = true;  IGNORE_CASE = true;}PARSER_BEGIN(SimpleDBMSParser)public class SimpleDBMSParser{  /*Query Comments Number */  public static final int PRINT_SYNTAX_ERROR = 0;  public static final int PRINT_CREATE_TABLE = 1;  public static final int PRINT_DROP_TABLE = 2;  public static final int PRINT_DESC = 3;  public static final int PRINT_SHOW_TABLES = 4;  public static final int PRINT_SELECT = 5;  public static final int PRINT_INSERT = 6;  public static final int PRINT_DELETE = 7;    public static void main(String args[]) throws ParseException  {    SimpleDBMSParser parser = new SimpleDBMSParser(System.in);    System.out.print("DB_2019-12345> ");    while (true)    {      try      {        parser.command();              }      catch (Exception e)      {        printMessage(PRINT_SYNTAX_ERROR);        //System.out.println(e.getMessage()); // for Debug, if you remove comment symbol, you can see what token is not matched when error comes.        SimpleDBMSParser.ReInit(System.in);      }    }  }/* Print Query Comments and Error Message */  public static void printMessage(int q)  {    switch(q)    {      case PRINT_SYNTAX_ERROR:      	System.out.println("Syntax error");      	break;      case PRINT_CREATE_TABLE:      	System.out.println("\'CREATE TABLE\' requested");      	break;      case PRINT_DROP_TABLE:      	System.out.println("\'DROP TABLE\' requested");      	break;  	  case PRINT_DESC:  	  	System.out.println("\'DESC\' requested");  	  	break;  	  case PRINT_SHOW_TABLES:  	  	System.out.println("\'SHOW TABLES\' requested");  	  	break;  	  case PRINT_SELECT:  	  	System.out.println("\'SELECT\' requested");  	  	break;  	  case PRINT_INSERT:  	  	System.out.println("\'INSERT\' requested");  	  	break;  	  case PRINT_DELETE:  	  	System.out.println("\'DELETE\' requested");  	  	break;  	      }    System.out.print("DB_2019-12345> ");  }}PARSER_END(SimpleDBMSParser)< DEFAULT >SKIP : { " " | "\r" | "\t" | "\n" }< DEFAULT >TOKEN : /* Keywords */// keywords should be ABOVE any other tokens because this arrangement can catch violation on using keywords {  < EXIT : "exit" >| < INT : "int" >| < CHAR : "char" >| < DATE : "date" >| < CREATE_TABLE : "create table" >| < NOT : "not" >| < NULL : "null" >| < NOT_NULL : "not null" >| < PRIMARY_KEY : "primary key" >| < FOREIGN_KEY : "foreign key" >| < REFERENCES : "references" >| < DROP_TABLE : "drop table" >| < DESC : "desc" >| < SHOW_TABLES : "show tables" >| < SELECT : "select" >| < AS : "as" >| < FROM : "from" >| < WHERE : "where" >| < OR : "or" >| < AND : "and" >| < IS : "is" >| < INSERT_INTO : "insert into" >| < VALUES : "values" >| < DELETE_FROM : "delete from" >| < STAR : "*" >} < STRING >SKIP : {"\r" | "\t" | "\n" } // In "STRING" state, " "(SPACE) does not skipped.< STRING >TOKEN :{  < SPACE : " " >| < CLOSE_QUOTE : "\'" > : DEFAULT| < NON_QUOTE_CHARACTER : < DIGIT > | < ALPHABET > | < NON_QUOTE_SPECIAL_CHARACTERS > | < SPACE > >| < NON_QUOTE_SPECIAL_CHARACTERS : "!" | "@" | "#" | "~" | "`" | "$" | "%" | "^" | "&" | "*" | "(" | ")" |								   "_" | "-" | "[" | "]" | "{" | "}" | "\\" | "|" | ";" | ":" | "<" | ">" |								   "," | "." | "/" | "?" | "+" | "=" >}< DEFAULT >TOKEN :{  < PERIOD : "." >| < SEMICOLON : ";" >| < LEFT_PAREN : "(" >| < RIGHT_PAREN : ")" >| < COMMA : "," >| < UNDERSCORE : "_" >| < INT_VALUE : (< SIGN >)? (< DIGIT >)+ >| < SIGN : "+" | "-" >| < OPEN_QUOTE : "\'" > : STRING| < DATE_VALUE : < NNNN > "-" <NN > "-" < NN > >| < NNNN : < DIGIT > <DIGIT > <DIGIT > <DIGIT > >| < NN : < DIGIT > < DIGIT > >| < LEGAL_IDENTIFIER : < ALPHABET > (< ALPHABET > | < UNDERSCORE >)* >| < COMP_OP : "<" | ">" | "=" | ">=" | "<=" | "!=" >}< * >TOKEN :{< DIGIT : [ "0"-"9" ] >| < ALPHABET : [ "a"-"z", "A"-"Z" ] >| < DOUBLE_QUOTE : "\"" > // this token never used but should be defined because it can be typed into input.}void command() :{}{  queryList()| (    < EXIT >    < SEMICOLON >    {      System.exit(0);    }  ) }void queryList() :{  int q;}{  (    q = query()    < SEMICOLON >    {      printMessage(q);    }  )+}int query() :{  int q; // it will be Query Comment Number.}{  (    createTableQuery()    {      q = PRINT_CREATE_TABLE;    }|  	dropTableQuery()  	{  	  q = PRINT_DROP_TABLE;  	}| 	descQuery() 	{ 	  q = PRINT_DESC; 	}|	showTablesQuery()	{	  q = PRINT_SHOW_TABLES;	}|	selectQuery()	{	  q = PRINT_SELECT;	}|	insertQuery()	{	  q = PRINT_INSERT;	}|	deleteQuery()	{	  q = PRINT_DELETE;	}  )  (    {      return q;    }  )}void deleteQuery() :{}{  < DELETE_FROM >  tableName()  (    whereClause()  )?}void insertQuery() :{}{  < INSERT_INTO >  tableName()  insertColumnsAndSource()}void insertColumnsAndSource() :{}{  (    columnNameList()  )?  valueList()}void valueList() :{}{  < VALUES >  < LEFT_PAREN >  value()  (    < COMMA >    value()  )*  < RIGHT_PAREN >}void value() :{}{  < NULL > | comparableValue()}void selectQuery() :{}{  < SELECT >  selectList()  tableExpression()}void tableExpression() :{}{  fromClause()  (    whereClause()  )?}void whereClause() :{}{  < WHERE >  booleanValueExpression()}void booleanValueExpression() :{}{  booleanTerm()  (    < OR >    booleanTerm()  )*}void booleanTerm() :{}{  booleanFactor()  (    < AND >    booleanFactor()  )*}void booleanFactor() :{}{  (    < NOT >  )?  booleanTest()}void booleanTest() :{}{  predicate() | parenthesizedBooleanExpression()}void parenthesizedBooleanExpression() :{}{  < LEFT_PAREN >  booleanValueExpression()  < RIGHT_PAREN >}void predicate() :{}{  LOOKAHEAD(4) // it can solve the conflict comparisonPredicate() and nullPredicate()  comparisonPredicate()  |  nullPredicate()}void nullPredicate() :{}{  (    LOOKAHEAD(2) // it can solve the conflict tableName()and columnName()     tableName()    < PERIOD >  )?  columnName()  nullOperation()}void nullOperation() :{}{  < IS > (< NULL > | < NOT_NULL >)}void comparisonPredicate() :{}{  compOperand()  < COMP_OP >  compOperand()}void compOperand() :{}{  comparableValue()  |    (      (        LOOKAHEAD(2) // it can solve the conflict tableName()and columnName()         tableName()        < PERIOD >      )?      columnName()    )}void comparableValue() :{}{  < INT_VALUE > | charString() | < DATE_VALUE >}void charString() :{}{	< OPEN_QUOTE >	//Switch the lexical state : DEFAULT - > STRING	(< NON_QUOTE_CHARACTER >)*	< CLOSE_QUOTE >	//Switch the lexical state : STRING - > DEFAULT}void fromClause() :{}{  < FROM >  tableReferenceList()}void tableReferenceList() :{}{  referedTable()  (    < COMMA >    referedTable()  )*}void referedTable() :{}{  tableName()  (    < AS >    tableName()  )?}void selectList() :{}{  < STAR >|  (    selectedColumn()    (      < COMMA >      selectedColumn()    )*  )}void selectedColumn() :{}{  (    LOOKAHEAD(2) // it can solve the conflict tableName()and columnName()     tableName()    < PERIOD >  )?  columnName()  (    < AS >    columnName()  )?}  void showTablesQuery() :{}{  < SHOW_TABLES >}void descQuery() :{} {  < DESC >  tableName()}void dropTableQuery() :{}{  < DROP_TABLE >  tableName()}void createTableQuery() :{}{  < CREATE_TABLE >  tableName()  tableElementList()}void tableElementList() :{}{  < LEFT_PAREN >  tableElement()  (    < COMMA >    tableElement()  )*  < RIGHT_PAREN >}void tableElement() :{}{  columnDefinition()| tableConstraintDefinition()}void columnDefinition() :{}{  columnName()  dataType()  (    < NOT_NULL >  )?}void tableConstraintDefinition() :{}{  primaryKeyConstraint()| referentialConstraint()}void primaryKeyConstraint() :{}{  < PRIMARY_KEY >  columnNameList()}void referentialConstraint() :{}{  < FOREIGN_KEY >  columnNameList()  < REFERENCES >  tableName()  columnNameList()}void columnNameList() :{}{  < LEFT_PAREN >  columnName()  (    < COMMA >    columnName()  )*  < RIGHT_PAREN >}void dataType() :{}{  < INT >| (    < CHAR >    < LEFT_PAREN >    < INT_VALUE >    < RIGHT_PAREN >  )| < DATE >}void tableName() :{}{  < LEGAL_IDENTIFIER >}void columnName() :{}{  < LEGAL_IDENTIFIER >}