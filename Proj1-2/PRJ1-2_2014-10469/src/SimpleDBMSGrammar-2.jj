options{  static = true;  DEBUG_PARSER = false;  IGNORE_CASE = true;}PARSER_BEGIN(SimpleDBMSParser)//importimport com.sleepycat.je.Database;import com.sleepycat.je.DatabaseException;import com.sleepycat.je.DatabaseConfig;import com.sleepycat.je.DatabaseEntry;import com.sleepycat.je.Cursor;import com.sleepycat.je.Environment;import com.sleepycat.je.EnvironmentConfig;import com.sleepycat.je.LockMode;import com.sleepycat.je.OperationStatus;import java.io.File;import java.io.UnsupportedEncodingException;import java.util.ArrayList;import java.util.Iterator;import custom.*;import com.sleepycat.bind.EntryBinding;import com.sleepycat.bind.serial.StoredClassCatalog;import com.sleepycat.bind.serial.SerialBinding;public class SimpleDBMSParser{  /*Query Comments Number */  public static final int PRINT_SYNTAX_ERROR = -1;  public static final int CREATE_TABLE_SUCCESS = 0;  public static final int DUPLICATE_COLUMN_DEF_ERROR = 1;  public static final int DUPLICATE_PRIMARYKEY_DEF_ERROR = 2;  public static final int REFERENCE_TYPE_ERROR = 3;  public static final int REFERENCE_NON_PRIMARYKEY_ERROR = 4;  public static final int REFERENCE_COLUMN_EXISTENCE_ERROR = 5;  public static final int REFERENCE_TABLE_EXISTENCE_ERROR = 6;  public static final int NON_EXISTING_COLUMN_DEF_ERROR = 7;  public static final int TABLE_EXISTENCE_ERROR = 8;  public static final int DROP_SUCCESS = 9;  public static final int DROP_REFERENCED_TABLE_ERROR = 10;  public static final int SHOW_TABLES_NO_TABLE = 11;  public static final int NO_SUCH_TABLE = 12;  public static final int CHAR_LENGTH_ERROR = 13;  public static final int PRINT_CREATE_TABLE = 1;  public static final int PRINT_DROP_TABLE = 2;  public static final int PRINT_DESC = 3;  public static final int PRINT_SHOW_TABLES = 4;  public static final int PRINT_SELECT = 5;  public static final int PRINT_INSERT = 6;  public static final int PRINT_DELETE = 7;  // Environment & Database define  public static Environment myDbEnvironment = null;  public static Database myDatabase = null;  public static Database myClassDb = null;  public static StoredClassCatalog classCatalog = null;  public static EntryBinding dataBinding = null;    public static void main(String args[]) throws ParseException  {    /* OPENING DB */	// Open Database Environment or if not, create one.	EnvironmentConfig envConfig = new EnvironmentConfig();	envConfig.setAllowCreate(true);	myDbEnvironment = new Environment(new File("db/"), envConfig);		// Open Database or if not, create one.	DatabaseConfig dbConfig = new DatabaseConfig();	dbConfig.setAllowCreate(true);	dbConfig.setSortedDuplicates(false);	myDatabase = myDbEnvironment.openDatabase(null, "tables", dbConfig);	// Open Database for 'Table' class information or if not, create one.	dbConfig.setSortedDuplicates(false);	myClassDb = myDbEnvironment.openDatabase(null, "classDb", dbConfig);    classCatalog = new StoredClassCatalog(myClassDb);	dataBinding = new SerialBinding(classCatalog, Table.class);	    SimpleDBMSParser parser = new SimpleDBMSParser(System.in);    System.out.print("DB_2014-10469> ");    while (true)    {      try      {        parser.command();              }      catch (Exception e)      {        printMessage(PRINT_SYNTAX_ERROR, "");        //System.out.println(e.getMessage()); // for Debug, if you remove comment symbol, you can see what token is not matched when error comes.        SimpleDBMSParser.ReInit(System.in);      }    }  }  /* describe table */  public static void desc(String table_name)  {    Table table;    Cursor cursor = null;    DatabaseEntry foundKey;	DatabaseEntry foundData;	//Get the table which name is 'table_name' from database	try {	  	foundKey = new DatabaseEntry(table_name.getBytes("UTF-8"));	  	foundData = new DatabaseEntry();	    cursor = myDatabase.openCursor(null, null);	    //Check if there is at least one table in database		if(cursor.getSearchKey(foundKey, foundData, LockMode.DEFAULT) != OperationStatus.SUCCESS)		{		  printMessage(NO_SUCH_TABLE, "");		}		else		{		  //describe table		  String keyString = new String(foundKey.getData(), "UTF-8");		  table = (Table) dataBinding.entryToObject(foundData);		  System.out.println("-------------------------------------------------");		  System.out.println("table_name [" + table.table_name + "]");		  System.out.println("column_name          type          null          key          ");		  Iterator it = table.attributes.iterator();		  while(it.hasNext())		  {		    Attribute A = (Attribute) it.next();		    String name = A.get_name();		    String keydesc = "";			String type = A.get_type();			char is_null = 'N';			if(A.get_is_null())				is_null = 'Y';			if (type.equals("char"))				type = type + "(" + A.get_len() + ")";		    		    if(table.is_primary_key(name))		    { 		    	keydesc += "PRI";		    }		    if(table.is_foreign_key(name))		    {		      if(keydesc.isEmpty())		      	keydesc += "FOR";		      else		      	keydesc += "/FOR";		    }			System.out.printf("%-21s%-14s%-14c%-14s\n", name, type, is_null, keydesc);		  }		  System.out.println("-------------------------------------------------");	  	}	} catch (Exception e) {	  e.printStackTrace();	} finally { 		cursor.close();    }	  }/* show all table's names in database */  public static void showTables()  {    Table table;    Cursor cursor = null;    DatabaseEntry foundKey = new DatabaseEntry();	DatabaseEntry foundData = new DatabaseEntry();		try {	    cursor = myDatabase.openCursor(null, null);	    //Check if there is at least one table in database	    if(cursor.getFirst(foundKey, foundData, LockMode.DEFAULT) != OperationStatus.SUCCESS)	   	{	   	  printMessage(SHOW_TABLES_NO_TABLE, "");	   	  	   	}	   	else	   	{	   	   //Show tables		    System.out.println("----------------");		    do {		      String keyString = new String(foundKey.getData(), "UTF-8");			  System.out.println(keyString);			} while (cursor.getNext(foundKey, foundData, LockMode.DEFAULT) == OperationStatus.SUCCESS);			System.out.println("----------------");		}	} catch (DatabaseException de) {	  System.err.println("Error accessing database." + de);	} catch (UnsupportedEncodingException e) {	} finally {	  cursor.close();	}  }    /* remove Table from database */	public static void dropTable(String table_name)	  {	    Table table;	    Cursor cursor = null;	    DatabaseEntry foundKey, foundData;		try {		    foundKey = new DatabaseEntry(table_name.getBytes("UTF-8"));			foundData = new DatabaseEntry();		    cursor = myDatabase.openCursor(null, null);		    //Check if target table is exist			if(cursor.getSearchKey(foundKey, foundData, LockMode.DEFAULT) == OperationStatus.SUCCESS)			{			  table = (Table) dataBinding.entryToObject(foundData); //table that you want to remove  			  //Check if any table doesn't reference this table, So it can be removed			  if(table.referenced.isEmpty())			  {			    //remove references that target table is referencing			    Iterator it = table.referencing.iterator();				while(it.hasNext())				{				  	String referenced_table_name = ((Reference) it.next()).refer_table;				  	DatabaseEntry key = new DatabaseEntry(referenced_table_name.getBytes("UTF-8"));				  	DatabaseEntry data = new DatabaseEntry();				    if(cursor.getSearchKey(key, data, LockMode.DEFAULT) == OperationStatus.SUCCESS)				    { 				  	  Table referenced_table = (Table) dataBinding.entryToObject(data);				  	  referenced_table.referenced.remove(table_name);				  	  dataBinding.objectToEntry(referenced_table, data);				  	  cursor.putCurrent(data);				    } 				}				//remove target table			  	myDatabase.delete(null, foundKey);			    printMessage(DROP_SUCCESS, table_name);			  }			  else			  {			    printMessage(DROP_REFERENCED_TABLE_ERROR, table_name);			  }			}			else			{			  printMessage(NO_SUCH_TABLE, "");			}		} catch (DatabaseException de) {	   	  System.err.println("Error accessing database." + de);		} catch (UnsupportedEncodingException e) {		} finally {	  	  cursor.close();	    }			}    /* Add Table to database */  public static void createTable(Table table)  {	Cursor cursor = null;	DatabaseEntry key;	DatabaseEntry data;	ArrayList<String> referenced_tables = new ArrayList();	try {	  cursor = myDatabase.openCursor(null, null);	  key = new DatabaseEntry(table.table_name.getBytes("UTF-8"));	  data = new DatabaseEntry();		  //check if target table is already exist	  if(cursor.getSearchKey(key, data, LockMode.DEFAULT) == OperationStatus.SUCCESS)	  {	    printMessage(TABLE_EXISTENCE_ERROR, "");	    cursor.close();	    return;	  }	  	  //check constraints according to columns(attributes)	  Iterator it;	  it = table.attributes.iterator();      while(it.hasNext())      {        Attribute A = (Attribute) it.next();        //check if column are not duplicated        if(table.is_attribute(A.get_name()) > 1)	    {          printMessage(DUPLICATE_COLUMN_DEF_ERROR, "");	      cursor.close();	      return;        }        //type check(check 'char' type which length is smaller than 1)		if(A.get_type().equalsIgnoreCase("char") && (A.get_len() < 1))		{		  printMessage(CHAR_LENGTH_ERROR, "");	      cursor.close();	      return;		}      }	    	  //check if primary keys is actually in attributes	  it = table.primary_keys.iterator();	  while(it.hasNext())	  {	    String primary_key = (String) it.next();	    if(table.is_attribute(primary_key) < 1)	    { 	      printMessage(NON_EXISTING_COLUMN_DEF_ERROR, primary_key);	      cursor.close();          return;        }        //if it is correct primary key, then corresponding attribute should be "not null"        Attribute A = table.get_attribute(primary_key);        A.set_is_null(false);	  }	  /* check for foreign key constraints */	  it = table.referencing.iterator();	  while(it.hasNext())	  {	    Reference Reference = (Reference) it.next();	    //check if foreign keys is actually in attributes	    Iterator it2 = Reference.refer_chaser_names.iterator();	    while(it2.hasNext())	    {	      String chaser = (String) it2.next();	      if(table.is_attribute(chaser) <  1)	      {	        printMessage(NON_EXISTING_COLUMN_DEF_ERROR, chaser);	        cursor.close();            return;	      }	    }		//check if the referenced table is actually exist	    key = new DatabaseEntry(Reference.refer_table.getBytes("UTF-8"));	    data = new DatabaseEntry();	    if(cursor.getSearchKey(key, data, LockMode.DEFAULT) != OperationStatus.SUCCESS)	    {	      printMessage(REFERENCE_TABLE_EXISTENCE_ERROR, "");	      cursor.close();	      return;	    }		//Check if reference column is actually exist and primary key		Table referenced_table = (Table) dataBinding.entryToObject(data);				//collect table names of referenced table for later purpose(A)		referenced_tables.add(referenced_table.table_name);	    it2 = Reference.refer_target_names.iterator();	    while(it2.hasNext())	    {	      String target = (String) it2.next();	      if(referenced_table.is_attribute(target) <  1)	      {	        printMessage(REFERENCE_COLUMN_EXISTENCE_ERROR, "");	        cursor.close();            return;	      }	      if(!referenced_table.is_primary_key(target))	      {	        printMessage(REFERENCE_NON_PRIMARYKEY_ERROR, "");	        cursor.close();            return;	      }	    }	    //check if arities of referenced and referencing attributes are the same 	    int size = Reference.refer_target_names.size();		//check if foreign keys reference all attributes in primary key		if(size != referenced_table.primary_keys.size())		{		  printMessage(REFERENCE_NON_PRIMARYKEY_ERROR, "");	        cursor.close();            return;	    }	    	    if(size != Reference.refer_chaser_names.size())	    {	      printMessage(REFERENCE_TYPE_ERROR, "");	      cursor.close();          return;        }        for(int i = 0; i < size; i++)        {          Attribute temp1 = table.get_attribute(Reference.refer_chaser_names.get(i));          Attribute temp2 = referenced_table.get_attribute(Reference.refer_target_names.get(i));          if(temp1.get_type().equalsIgnoreCase(temp2.get_type()) && temp1.get_len() == temp2.get_len())          	continue;          else          {            printMessage(REFERENCE_TYPE_ERROR, "");	        cursor.close();            return;          }                  }        			   	  }	  /*(A) adding table_name for referencing table to referenced table */ 	  it = referenced_tables.iterator();	  while(it.hasNext())	  {	  	String table_name = (String) it.next();	  	key = new DatabaseEntry(table_name.getBytes("UTF-8"));	  	data = new DatabaseEntry();	  	cursor.getSearchKey(key, data, LockMode.DEFAULT);	  	Table referenced_table = (Table) dataBinding.entryToObject(data);	  	referenced_table.referenced.add(table.table_name);	  	dataBinding.objectToEntry(referenced_table, data);	  	cursor.putCurrent(data); 	  }	  /* create table */	  key = new DatabaseEntry(table.table_name.getBytes("UTF-8"));	  data = new DatabaseEntry();      dataBinding.objectToEntry(table, data);	  cursor.put(key, data);	  printMessage(CREATE_TABLE_SUCCESS, table.table_name);	  cursor.close();	} catch (DatabaseException de) {	  de.printStackTrace();	} catch (UnsupportedEncodingException e) {	  e.printStackTrace();	} catch (Exception g) {	  g.printStackTrace();	}  }/* Close Database and exit */  public static void readyToExit()  {    try { 		if (myClassDb != null) myClassDb.close();		if (myDatabase != null) myDatabase.close();		if (myDbEnvironment != null) myDbEnvironment.close();	} catch(Exception e)	{	  e.printStackTrace();	}	System.exit(0);  }/* print Messages and Errors */	public static void printMessage(int q, String n)	{	    switch(q)	    {	      case PRINT_SYNTAX_ERROR:	      	System.out.println("Syntex Error");	      	break;	      case CREATE_TABLE_SUCCESS:	      	System.out.println("\'" + n + "\' table is created");	      	break;	      case DUPLICATE_COLUMN_DEF_ERROR:	      	System.out.println("Create table has failed: column definition is duplicated");	      	break;	      case DUPLICATE_PRIMARYKEY_DEF_ERROR:	      	System.out.println("Create table has failed: primary key definition is duplicated");	      	break;	  	  case REFERENCE_TYPE_ERROR:	  	  	System.out.println("Create table has failed: foreign key references wrong type");	  	  	break;	  	  case REFERENCE_NON_PRIMARYKEY_ERROR:	  	  	System.out.println("Create table has failed: foreign key references non primary key column");	  	  	break;	  	  case REFERENCE_COLUMN_EXISTENCE_ERROR:	  	  	System.out.println("Create table has failed: foreign key references non existing column");	  	  	break;	  	  case REFERENCE_TABLE_EXISTENCE_ERROR:	  	  	System.out.println("Create table has failed: foreign key references non existing table");	  	  	break;	  	  case NON_EXISTING_COLUMN_DEF_ERROR:	  	  	System.out.println("Create table has failed: \'" + n + "\' does not exists in column definition");	  	  	break;	  	  case TABLE_EXISTENCE_ERROR:	  	  	System.out.println("Create table has failed: table with the same name already exists");	  	  	break;	  	  case DROP_SUCCESS:	  	  	System.out.println("\'" + n + "\' table is dropped");	  	  	break;	  	  case DROP_REFERENCED_TABLE_ERROR:	  	  	System.out.println("Drop table has failed: \'" + n + "\' is referenced by other table");	  	  	break;	  	  case SHOW_TABLES_NO_TABLE:	  	  	System.out.println("There is no table");	  	  	break;	  	  case NO_SUCH_TABLE:	  	  	System.out.println("No such table");	  	  	break;	  	  case CHAR_LENGTH_ERROR:	  	  	System.out.println("Char length should be over 0");	  	  	break;	  	  		  	  		  	  	    }	    System.out.print("DB_2019-12345> ");	}}PARSER_END(SimpleDBMSParser)//these characters in the middle of tokens will be ignored.SKIP : { " " | "\r" | "\t" | "\n" }TOKEN : /* Keywords */// keywords should be ABOVE any other tokens because this arrangement can catch violation on using keywords {  < EXIT : "exit" >| < INT : "int" >| < CHAR : "char" >| < DATE : "date" >| < CREATE_TABLE : "create table" >| < NOT : "not" >| < NULL : "null" >| < NOT_NULL : "not null" >| < PRIMARY_KEY : "primary key" >| < FOREIGN_KEY : "foreign key" >| < REFERENCES : "references" >| < DROP_TABLE : "drop table" >| < DESC : "desc" >| < SHOW_TABLES : "show tables" >| < SELECT : "select" >| < AS : "as" >| < FROM : "from" >| < WHERE : "where" >| < OR : "or" >| < AND : "and" >| < IS : "is" >| < INSERT_INTO : "insert into" >| < VALUES : "values" >| < DELETE_FROM : "delete from" >| < STAR : "*" >} < STRING >TOKEN :{  < SPACE : " " >| < NON_QUOTE_CHARACTER : < DIGIT > | < ALPHABET > | < NON_QUOTE_SPECIAL_CHARACTERS > | < SPACE > >| < NON_QUOTE_SPECIAL_CHARACTERS : "!" | "@" | "#" | "~" | "`" | "$" | "%" | "^" | "&" | "*" | "(" | ")" |								   "_" | "-" | "[" | "]" | "{" | "}" | "\\" | "|" | ";" | ":" | "<" | ">" |								   "," | "." | "/" | "?" | "+" | "=" >}TOKEN :{  < PERIOD : "." >| < SEMICOLON : ";" >| < LEFT_PAREN : "(" >| < RIGHT_PAREN : ")" >| < COMMA : "," >| < UNDERSCORE : "_" >| < INT_VALUE : (< SIGN >)? (< DIGIT >)+ >| < SIGN : "+" | "-" >| < QUOTE : "\'" > | < DATE_VALUE : < NNNN > "-" <NN > "-" < NN > >| < NNNN : < DIGIT > <DIGIT > <DIGIT > <DIGIT > >| < NN : < DIGIT > < DIGIT > >| < LEGAL_IDENTIFIER : < ALPHABET > (< ALPHABET > | < UNDERSCORE >)* >| < COMP_OP : "<" | ">" | "=" | ">=" | "<=" | "!=" >| < CHAR_STRING : < QUOTE > (< NON_QUOTE_CHARACTER >)* < QUOTE > >| < DIGIT : [ "0"-"9" ] >| < ALPHABET : [ "a"-"z", "A"-"Z" ] >| < DOUBLE_QUOTE : "\"" > // this token never used but should be defined because it can be typed into input.}//parse the whole SQL commandvoid command():{}{  queryList()| (    < EXIT >    < SEMICOLON >    {      readyToExit();    }  ) }//parse querylist = > query;query;query;...//after parse each query, it print message according to query comment numbervoid queryList():{  int q;  queryConfig qC = new queryConfig(); //contains information from query to use after syntax check.}{  (    q = query(qC)    < SEMICOLON >    {	  switch(q)	  {	    case PRINT_CREATE_TABLE:	    	//check if primary definition is more than 1 	    	if(qC.primary_def_count > 1)	    	{ 	    		printMessage(DUPLICATE_PRIMARYKEY_DEF_ERROR, "");	    		return;	        }	    	createTable(qC.table);	    	break;		case PRINT_DROP_TABLE:			dropTable(qC.table_name);			break;  		case PRINT_DESC:  			desc(qC.table_name);  			break;  		case PRINT_SHOW_TABLES:  			showTables();  			break;  		case PRINT_SELECT:  			break;  		case PRINT_INSERT:  			break;  		case PRINT_DELETE:  			break;       }       qC = new queryConfig();    }  )+}// parse queryint query(queryConfig qC):{  int q; // it will be Query Comment Number.}{  (    qC.primary_def_count = createTableQuery(qC.table)    {      q = PRINT_CREATE_TABLE;    }|  	qC.table_name = dropTableQuery()  	{  	  q = PRINT_DROP_TABLE;  	}| 	qC.table_name = descQuery() 	{ 	  q = PRINT_DESC;  	}|	showTablesQuery()	{	  q = PRINT_SHOW_TABLES;	}|	selectQuery()	{	  q = PRINT_SELECT;	}|	insertQuery()	{	  q = PRINT_INSERT;	}|	deleteQuery()	{	  q = PRINT_DELETE;	}  )  (    {      return q;    }  )}void deleteQuery() :{}{  < DELETE_FROM >  tableName()  (    whereClause()  )?}void insertQuery() :{}{  < INSERT_INTO >  tableName()  insertColumnsAndSource()}void insertColumnsAndSource() :{}{  (    columnNameList()  )?  valueList()}void valueList() :{}{  < VALUES >  < LEFT_PAREN >  value()  (    < COMMA >    value()  )*  < RIGHT_PAREN >}void value() :{}{  < NULL > | comparableValue()}void selectQuery() :{}{  < SELECT >  selectList()  tableExpression()}void tableExpression() :{}{  fromClause()  (    whereClause()  )?}void whereClause() :{}{  < WHERE >  booleanValueExpression()}void booleanValueExpression() :{}{  booleanTerm()  (    < OR >    booleanTerm()  )*}void booleanTerm() :{}{  booleanFactor()  (    < AND >    booleanFactor()  )*}void booleanFactor() :{}{  (    < NOT >  )?  booleanTest()}void booleanTest() :{}{  predicate() | parenthesizedBooleanExpression()}void parenthesizedBooleanExpression() :{}{  < LEFT_PAREN >  booleanValueExpression()  < RIGHT_PAREN >}void predicate() :{}{  LOOKAHEAD(4) // it can solve the conflict comparisonPredicate() and nullPredicate()  comparisonPredicate()  |  nullPredicate()}void nullPredicate() :{}{  (    LOOKAHEAD(2) // it can solve the conflict tableName()and columnName()     tableName()    < PERIOD >  )?  columnName()  nullOperation()}void nullOperation() :{}{  < IS > (< NOT > < NULL > | < NULL > | < NOT_NULL >) // "not null"이 create table의 키워드로 받아져 신텍스 에러를 낼 경우를 감안하여 < NOT_NULL > 토큰도 포함시켰다.}void comparisonPredicate() :{}{  compOperand()  < COMP_OP >  compOperand()}void compOperand() :{}{  comparableValue()  |    (      (        LOOKAHEAD(2) // it can solve the conflict tableName()and columnName()         tableName()        < PERIOD >      )?      columnName()    )}void comparableValue() :{}{  < INT_VALUE > | < CHAR_STRING > | < DATE_VALUE >}void fromClause() :{}{  < FROM >  tableReferenceList()}void tableReferenceList() :{}{  referedTable()  (    < COMMA >    referedTable()  )*}void referedTable() :{}{  tableName()  (    < AS >    tableName()  )?}void selectList() :{}{  < STAR >|  (    selectedColumn()    (      < COMMA >      selectedColumn()    )*  )}void selectedColumn() :{}{  (    LOOKAHEAD(2) // it can solve the conflict tableName()and columnName()     tableName()    < PERIOD >  )?  columnName()  (    < AS >    columnName()  )?}  void showTablesQuery() :{}{  < SHOW_TABLES >}String descQuery() :{  String table_name;} {  < DESC >  table_name = tableName()  {  return table_name;  }}String dropTableQuery() :{  String table_name;}{  < DROP_TABLE >  table_name = tableName()  {  return table_name;  }}int createTableQuery(Table table):{  int pdc = 0;}{	  < CREATE_TABLE >	  table.table_name = tableName()	  pdc = tableElementList(table)	  {	    return pdc;	  }}int tableElementList(Table table):{	int primary_def_count = 0;	int temp;}{  < LEFT_PAREN >  temp = tableElement(table)  {    primary_def_count += temp;  }  (    < COMMA >    temp = tableElement(table)    {      primary_def_count += temp;    }  )*  < RIGHT_PAREN >  {    return primary_def_count;  }}int tableElement(Table table):{  Attribute attribute = new Attribute();  int primary_def_count = 0;}{  (      (      columnDefinition(attribute)    {  		table.attributes.add(attribute);    }  )	| primary_def_count = tableConstraintDefinition(table))  {    return primary_def_count;  }}void columnDefinition(Attribute attribute) :{  String temp;}{  temp = columnName()  {    attribute.set_name(temp);  }  dataType(attribute)  (     < NOT_NULL >    {      attribute.set_is_null(false);    }  )?}int tableConstraintDefinition(Table table) :{	int primary_def_count = 0;}{  (    primaryKeyConstraint(table)    {      primary_def_count = 1;    }| referentialConstraint(table))  {	return primary_def_count;  }}void primaryKeyConstraint(Table table) :{}{  < PRIMARY_KEY >  table.primary_keys = columnNameList()}void referentialConstraint(Table table) :{	ArrayList<String> referencing;	ArrayList<String> referenced;	String reference_table;	Reference temp = new Reference();}	{  < FOREIGN_KEY >  referencing = columnNameList()  < REFERENCES >  reference_table = tableName()  referenced = columnNameList()  {    temp.refer_chaser_names = referencing;    temp.refer_target_names = referenced;    temp.refer_table = reference_table;    table.referencing.add(temp);      }}ArrayList<String> columnNameList() :{	ArrayList<String > list =  new ArrayList();	String temp;}{  < LEFT_PAREN >  temp = columnName()  {    list.add(temp);  }  (    < COMMA >    temp = columnName()    {      list.add(temp);    }  )*  < RIGHT_PAREN >  {	return list;  }}void dataType(Attribute attribute) :{  String type = null;  Token temp;  Token length_temp;  }{  (      temp = < INT >| (    temp = < CHAR >    < LEFT_PAREN >    length_temp = < INT_VALUE >    {      attribute.set_len(Integer.parseInt(length_temp.toString()));    }    < RIGHT_PAREN >  )| temp = < DATE >)(	{		attribute.set_type(temp.toString());		return;	})}String tableName() :{  Token t; }{  (t = < LEGAL_IDENTIFIER >)  {	return t.toString();  }}String columnName() :{	Token t;  }{  t = < LEGAL_IDENTIFIER >  {    return t.toString();  }}